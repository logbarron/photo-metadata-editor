<!--
Photo Metadata Editor UI
Copyright (C) 2025 Logan Barron

This file is part of Photo Metadata Editor.
Licensed under GPL v3 - see LICENSE file for details.
-->

<!DOCTYPE html>
<html>
<head>
    <title>Photo Metadata Editor</title>
    <meta charset="utf-8">
    <style>
        /* Design System */
        :root {
            --bg-primary: #000000;
            --bg-secondary: #1C1C1E;
            --bg-tertiary: rgba(255, 255, 255, 0.05);
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --border-color: rgba(255, 255, 255, 0.1);
            
            /* Source colors */
            --source-user: #34C759;
            --source-system: #FF9500;
            --source-filename: #007AFF;
            
            /* Status colors */
            --status-error: #FF453A;
            --status-warning: #FF9500;
            --status-success: #34C759;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }
        
        .container {
            display: grid;
            grid-template-columns: 320px 1fr 420px;
            height: 100vh;
        }
        
        /* Progress Panel */
        .progress-panel {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 24px;
            overflow-y: auto;
        }
        
        .stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(4px);
        }
        
        .stat-card.active {
            background: rgba(0, 122, 255, 0.15);
            border-color: var(--source-filename);
        }

        .stat-card.grid-mode {
            background: rgba(0, 122, 255, 0.15);
            border-color: var(--source-filename);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card.grid-mode::after {
            content: "";
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background-image: url("data:image/svg+xml,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='5' y='5' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='10' y='5' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='15' y='5' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='5' y='10' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='10' y='10' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='15' y='10' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='5' y='15' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='10' y='15' width='4' height='4' fill='%23007AFF'/%3E%3Crect x='15' y='15' width='4' height='4' fill='%23007AFF'/%3E%3C/svg%3E");
            background-size: contain;
            opacity: 0.7;
        }
        
        /* Grid view styles */
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            grid-auto-rows: minmax(120px, 1fr);  /* Fix: define row height */
            gap: 12px;
            padding: 20px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: auto;
            overflow-x: hidden;
            background: var(--bg-primary);
            align-content: start;
            box-sizing: border-box;
        }
        
        .grid-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;            /* fill container height */
        flex-direction: column;
        gap: 16px;
        color: var(--text-secondary);
        grid-column: 1 / -1;     /* span all columns */
        }
        
        .grid-item {
            position: relative;
            aspect-ratio: 1;
            width: 100%;
            height: 100%;  /* Fix: use full track height */
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-secondary);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .grid-item:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            z-index: 10;
        }

        /* Highlight the current thumbnail */
        .grid-item.current-photo {
            outline: 3px solid var(--source-filename);
            outline-offset: 2px;
            animation: pulse 0.6s ease-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .grid-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .grid-index {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 700;
        }
        
        /* Photo Preview */
        .photo-preview {
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }
        
        .photo-header {
            background: var(--bg-secondary);
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .photo-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            position: relative;
            overflow: hidden;  /* Prevent container from scrolling */
        }
        
        .photo-container.grid-mode {
            padding: 0;  /* No padding in grid mode */
        }
        
        .photo-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        /* Metadata Panel */
        .metadata-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .suggestion-btn {
            background: var(--source-filename);
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }
        
        .suggestion-btn:hover {
            opacity: 0.8;
        }

        /* Dual location suggestion buttons */
        .location-dual-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
            margin-top: 8px;
            margin-bottom: 16px;
        }
        
        .location-dual-container .btn {
            padding: 4px 12px;
            font-size: 12px;
            background: var(--source-filename);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: opacity 0.3s ease;
            text-align: left;
            font-weight: normal;
            display: inline-block;
        }
        
        .location-dual-container .btn:hover {
            opacity: 0.8;
        }
        
        .location-dual-container .btn.alternate {
            background: var(--source-filename);
        }
        
        /* Input Fields */
        .input-group {
            margin-bottom: 16px;
        }
        
        .input-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .source-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .source-badge.user {
            background: var(--source-user);
            color: white;
        }
        
        .source-badge.system {
            background: var(--source-system);
            color: white;
        }
        
        .input-field {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .input-field:focus {
            outline: none;
            border-color: var(--source-filename);
            background: rgba(255, 255, 255, 0.08);
        }
        
        .input-field.system-value {
            background: rgba(255, 149, 0, 0.1);
            border-color: var(--source-system);
        }
        
        .input-field.unknown-value,
        .location-search-input.unknown-value {
            background: rgba(52, 199, 89, 0.1);
            border-color: #34C759;
        }
        
        .input-field:disabled,
        .location-search-input:disabled {
            opacity: 1;
            color: #34C759;
            -webkit-text-fill-color: #34C759;
            cursor: not-allowed;
        }
        
        /* Date inputs grid */
        .date-inputs {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 8px;
        }
        
        /* Location Search Styles */
        .location-container {
            position: relative;
        }

        .location-search-wrapper {
            position: relative;
        }

        .location-search-input {
            width: 100%;
            height: 44px;
            background: rgba(118, 118, 128, 0.12);
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 0 40px 0 36px;
            color: #fff;
            font-size: 16px;
            transition: all 0.2s ease;
            -webkit-appearance: none;
        }

        .location-search-input:focus {
            outline: none;
            background: rgba(118, 118, 128, 0.24);
            border: 1px solid var(--source-filename);
        }
        
        .location-search-input.unknown-value:focus {
            border-color: #34C759;
        }

        .location-search-input::placeholder {
            color: rgba(235, 235, 245, 0.3);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            opacity: 0.6;
            pointer-events: none;
        }

        .clear-button {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            background: rgba(118, 118, 128, 0.24);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .location-results {
            margin-top: 8px;
            background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
        }

        .result-section {
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .result-section:last-child {
            border-bottom: none;
        }

        .section-header {
            padding: 8px 16px 4px;
            font-size: 11px;
            font-weight: 600;
            color: #8E8E93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .result-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.1s ease;
        }

        .result-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .result-item.current {
            background: rgba(0, 122, 255, 0.15);
        }

        .result-category {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            margin-right: 12px;
            flex-shrink: 0;
            min-width: 60px;
            text-align: center;
        }

        .result-category.state,
        .result-category.city,
        .result-category.address,
        .result-category.poi,
        .result-category.country {
            background: rgba(52, 199, 89, 0.2);
            border-color: #34C759;
            color: #34C759;
        }

        .result-content {
            flex: 1;
            min-width: 0;
        }

        .result-title {
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .result-subtitle {
            font-size: 13px;
            color: #8E8E93;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        .will-save-text {
            color: #64B5FF;
            font-style: italic;
        }

        .result-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
        }

        .usage-badge {
            background: rgba(255, 204, 0, 0.2);
            color: #FFCC00;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .checkmark {
            width: 22px;
            height: 22px;
            color: #34C759;
        }

        .frequent-pills {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .frequent-pill {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 6px 14px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }

        .frequent-pill:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .pill-text {
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pill-count {
            font-size: 11px;
            color: #8E8E93;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        /* Enhanced metadata display */
        .location-display {
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .location-details {
            flex: 1;
            min-width: 0;
        }

        .location-primary {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 2px;
        }

        .location-secondary {
            font-size: 12px;
            color: #8E8E93;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .empty-results {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }
        
        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--source-filename);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Quick Actions */
        .quick-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
        }
        
        .quick-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .quick-btn:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .quick-btn.active {
            background: rgba(52, 199, 89, 0.2);
            border: 1px solid #34C759;
            color: #34C759;
        }
        
        .quick-btn.active:hover {
            background: rgba(52, 199, 89, 0.3);
        }
        
        /* Action Buttons */
        .action-buttons {
            margin-top: auto;
            display: flex;
            gap: 12px;
            padding-top: 24px;
        }
        
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: var(--source-filename);
            color: white;
        }
        
        .btn-primary:hover {
            opacity: 0.9;
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-import {
            background: var(--source-user);
            color: white;
        }
        
        .btn-import:hover {
            opacity: 0.9;
        }
        
        .btn-import:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-import.warning-state {
            background: var(--status-warning);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .btn[title] {
            position: relative;
        }
        
        /* Current Metadata Display */
        .current-metadata {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin-top: 24px;
        }
        
        .metadata-item {
            margin-bottom: 12px;
        }
        
        .metadata-label {
            color: var(--text-secondary);
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .metadata-value {
            font-size: 14px;
            font-family: monospace;
        }
        
        /* Navigation */
        .nav-controls {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            transform: translateY(-50%);
            pointer-events: none;
        }
        
        .nav-btn {
            background: rgba(28, 28, 30, 0.9);
            border: 1px solid var(--border-color);
            color: white;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: rgba(0, 122, 255, 0.2);
            border-color: var(--source-filename);
        }
        
        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Attribution */
        .attribution {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
        }
        
        /* Sort Toggle */
        .sort-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .sort-toggle input {
            display: none;
        }
        
        .toggle-slider {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            transition: background 0.3s ease;
        }
        
        .toggle-slider::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }
        
        .sort-toggle input:checked + .toggle-slider {
            background: var(--source-user);
        }
        
        .sort-toggle input:checked + .toggle-slider::after {
            transform: translateX(16px);
        }
        
        .toggle-label {
            transition: color 0.3s ease;
        }
        
        .sort-toggle input:checked ~ .toggle-label {
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Progress Panel -->
        <div class="progress-panel">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;">
                <h2 style="margin: 0;">Filters</h2>
                <label class="sort-toggle">
                    <input type="checkbox" id="sort-toggle" onchange="toggleSort()">
                    <span class="toggle-slider"></span>
                    <span class="toggle-label">Sort by #</span>
                </label>
            </div>
            
            <div class="stat-card active" onclick="setFilter('needs_review', this)">
                <div class="stat-label">Needs Review</div>
                <div class="stat-value" style="color: var(--source-filename);" id="stat-needs-review">0</div>
            </div>
            
            <div class="stat-card" onclick="setFilter('needs_both', this)">
                <div class="stat-label">Needs Both</div>
                <div class="stat-value" style="color: var(--status-error);" id="stat-needs-both">0</div>
            </div>
            
            <div class="stat-card" onclick="setFilter('needs_location', this)">
                <div class="stat-label">Needs Location</div>
                <div class="stat-value" style="color: var(--status-warning);" id="stat-needs-location">0</div>
            </div>
            
            <div class="stat-card" onclick="setFilter('needs_date', this)">
                <div class="stat-label">Needs Date</div>
                <div class="stat-value" style="color: var(--status-warning);" id="stat-needs-date">0</div>
            </div>
            
            <div class="stat-card" onclick="setFilter('complete', this)">
                <div class="stat-label">Complete</div>
                <div class="stat-value" style="color: var(--status-success);" id="stat-complete">0</div>
            </div>
            
            <!-- Current metadata -->
            <div class="current-metadata">
                <h3 style="font-size: 16px; margin-bottom: 16px;">Current Metadata</h3>
                <div class="metadata-item">
                    <div class="metadata-label">Date</div>
                    <div class="metadata-value" id="current-date">Not set</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-label">Location</div>
                    <div class="metadata-value" id="current-location">Not set</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-label">Tags</div>
                    <div class="metadata-value" id="current-tags">None</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-label">Import Status</div>
                    <div class="metadata-value" id="current-import-status">Not imported</div>
                </div>
            </div>
        </div>
        
        <!-- Photo Preview -->
        <div class="photo-preview">
            <div class="photo-header">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div id="filename" style="font-size: 16px; font-weight: 500;">Loading...</div>
                    <div id="file-counter" style="font-size: 14px; color: var(--text-secondary);">0 of 0</div>
                </div>
            </div>
            
            <div class="photo-container">
                <div id="loading" class="loading">
                    <div class="spinner"></div>
                </div>
                <img id="photo" style="display: none;" />
                
                <div class="nav-controls">
                    <button class="nav-btn" id="prev-btn" onclick="navigatePhoto(-1)">←</button>
                    <button class="nav-btn" id="next-btn" onclick="navigatePhoto(1)">→</button>
                </div>
            </div>
        </div>
        
        <!-- Metadata Panel -->
        <div class="metadata-panel">
            <h2 style="margin-bottom: 24px;">Edit Metadata</h2>
            
            <!-- Quick Actions -->
            <div class="quick-actions">
                <button class="quick-btn" onclick="setUnknownDate()">Unknown Date</button>
                <button class="quick-btn" onclick="setUnknownLocation()">Unknown Location</button>
            </div>
            
            <!-- Date Section -->
            <div style="margin-bottom: 32px;">
                <div class="section-title">
                    Date
                </div>
                
                <button id="date-suggestion-btn" class="suggestion-btn" style="display: none; margin-top: 8px; margin-bottom: 16px;" 
                        onclick="acceptDateSuggestion()">Use suggestion</button>
                
                <div class="date-inputs">
                    <div class="input-group">
                        <label class="input-label">
                            Year
                            <span id="year-badge" class="source-badge" style="display: none;"></span>
                        </label>
                        <input type="text" id="year" class="input-field" placeholder="YYYY" maxlength="4" />
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            Month
                            <span id="month-badge" class="source-badge" style="display: none;"></span>
                        </label>
                        <input type="text" id="month" class="input-field" placeholder="MM" maxlength="2" />
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            Day
                            <span id="day-badge" class="source-badge" style="display: none;"></span>
                        </label>
                        <input type="text" id="day" class="input-field" placeholder="DD" maxlength="2" />
                    </div>
                </div>
            </div>
            
            <!-- Location Section -->
            <div style="margin-bottom: 32px;">
                <div class="section-title">
                    Location
                    <button id="location-suggestion-btn" class="suggestion-btn" style="display: none;" 
                            onclick="window.acceptLocationSuggestion ? window.acceptLocationSuggestion() : acceptLocationSuggestion()">Use suggestion</button>
                </div>
                
                <!-- NEW UNIFIED LOCATION SEARCH -->
                <div class="location-container">
                    <div class="location-search-wrapper">
                        <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        <input type="text" 
                               id="location-search" 
                               class="location-search-input"
                               placeholder="Search for a place"
                               autocomplete="off">
                        <button class="clear-button" id="location-clear" style="display: none;">
                            <svg width="14" height="14" fill="currentColor" viewBox="0 0 14 14">
                                <path d="M7 0C3.13 0 0 3.13 0 7s3.13 7 7 7 7-3.13 7-7-3.13-7-7-7zm3.5 9.5L9 11 7 9 5 11 3.5 9.5 5.5 7.5 3.5 5.5 5 4l2 2 2-2 1.5 1.5L8.5 7.5l2 2z"/>
                            </svg>
                        </button>
                    </div>
                    
                    <!-- Results dropdown -->
                    <div id="location-results" class="location-results" style="display: none;">
                        <!-- Populated dynamically -->
                    </div>
                    
                    <!-- Frequent pills -->
                    <div id="frequent-pills" class="frequent-pills">
                        <!-- Populated on load -->
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn btn-primary" id="save-btn" onclick="saveAndNext()" title="Save metadata (⌘S)">Save</button>
                <button class="btn btn-import" id="send-button" onclick="sendToPhotos()">Send to Photos</button>
            </div>
            
            <div id="import-status" style="margin-top: 12px; display: none;"></div>
            
            <!-- Attribution -->
            <div class="attribution">
                Location search powered by Apple Maps
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let currentPhoto = null;
        let dateSuggestion = null;
        let locationSuggestion = null;
        let gridMode = false;
        let currentGridFilter = null;
        // Selection tracking for import feature
        let selectedPhotos = new Set();
        
        // LLM polling state
        let llmPollTimeout = null;
        let llmPollCount = 0;
        
        // Re-send state tracking
        let resendTimeout = null;
        let resendPending = false;
        let fieldSources = {
            year: null,
            month: null,
            day: null,
            wasCompleteSuggestion: false
        };
        let unknownDateActive = false;
        let unknownLocationActive = false;
        
        // Clear re-send state and prevent memory leaks
        function clearResendState() {
            if (resendTimeout) {
                clearTimeout(resendTimeout);
                resendTimeout = null;
            }
            resendPending = false;
            
            // Reset button text if needed
            const sendBtn = document.getElementById('send-button');
            if (sendBtn && currentPhoto && currentPhoto.imported_at) {
                sendBtn.textContent = 'Already in Photos';
                sendBtn.classList.remove('warning-state');
            }
        }

        // Location search state
        let locationSearchState = {
            currentLocation: null,
            searchTimeout: null,
            results: []
        };
        
        function updateSelectionUI() {
            // Update send button based on current mode
            const sendButton = document.getElementById('send-button');
            
            if (!gridMode) {
                // In single photo mode, enable if saved (even if imported for re-send feature)
                const canSend = currentPhoto && currentPhoto.last_saved_at;
                if (sendButton) sendButton.disabled = !canSend;
            } else {
                // In grid mode, update selection count and button
                const gridCount = document.getElementById('grid-selection-count');
                const gridSendButton = document.getElementById('grid-send-button');
                
                if (gridCount) {
                    gridCount.textContent = `${selectedPhotos.size} photos selected`;
                }
                if (gridSendButton) {
                    gridSendButton.disabled = selectedPhotos.size === 0;
                }
            }
        }
        
        function selectAllVisible() {
            if (gridMode) {
                // In grid mode, select all visible non-imported photos
                const checkboxes = document.querySelectorAll('.grid-checkbox:not(:disabled)');
                checkboxes.forEach(cb => {
                    cb.checked = true;
                    selectedPhotos.add(cb.dataset.filepath);
                });
            } else {
                // In single photo mode, add current photo if not imported
                selectedPhotos.clear();
                if (currentPhoto && !currentPhoto.imported_at) {
                    selectedPhotos.add(currentPhoto.filepath);
                }
            }
            updateSelectionUI();
        }
        
        function selectNone() {
            selectedPhotos.clear();
            // Clear all grid checkboxes if in grid mode
            if (gridMode) {
                const checkboxes = document.querySelectorAll('.grid-checkbox');
                checkboxes.forEach(cb => cb.checked = false);
            }
            updateSelectionUI();
        }

        function toggleGridSelection(filepath, isImported, isUnsaved) {
            // Don't allow selection of imported photos or unsaved photos
            if (isImported || isUnsaved) return;
            
            const checkbox = event.target;
            if (checkbox.checked) {
                selectedPhotos.add(filepath);
            } else {
                selectedPhotos.delete(filepath);
            }
            updateSelectionUI();
        }
        
        async function sendToPhotos() {
            // In single photo mode, send current photo
            if (!gridMode) {
                if (!currentPhoto) {
                    alert('No photo currently loaded.');
                    return;
                }
                
                // Handle two-click pattern for already imported photos
                if (currentPhoto.imported_at) {
                    const sendBtn = document.getElementById('send-button');
                    
                    if (!resendPending) {
                        // First click - enter warning state
                        resendPending = true;
                        if (sendBtn) {
                            sendBtn.textContent = 'Click again to re-send';
                            sendBtn.classList.add('warning-state');
                        }
                        
                        // Set timeout to revert
                        resendTimeout = setTimeout(() => {
                            clearResendState();
                        }, 3000);
                        
                        return; // Don't proceed with send
                    } else {
                        // Second click - clear timeout and proceed
                        clearResendState();
                        // Continue to normal send flow
                    }
                }
                
                selectedPhotos.clear();
                selectedPhotos.add(currentPhoto.filepath);
            }
            
            const selected = Array.from(selectedPhotos);
            
            if (selected.length === 0) {
                alert('No photos selected.');
                return;
            }
            
            // Show loading state
            const importStatus = document.getElementById('import-status');
            importStatus.innerHTML = 
                '<div style="color: var(--source-filename);">Checking import status...</div>';
            importStatus.style.display = 'block';
            
            // Disable buttons during operation
            const sendButton = document.getElementById('send-button');
            const gridSendButton = document.getElementById('grid-send-button');
            const saveBtn = document.getElementById('save-btn');
            
            if (sendButton) sendButton.disabled = true;
            if (gridSendButton) gridSendButton.disabled = true;
            if (saveBtn) saveBtn.disabled = true;
            
            try {
                // Check for already imported photos
                const response = await fetch('/api/check-import-status', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({filepaths: selected})
                });
                
                const status = await response.json();
                const alreadyImported = status.filter(p => p.imported_at);
                
                if (alreadyImported.length > 0) {
                    if (!confirm(`WARNING: ${alreadyImported.length} photos are already imported!\n\n` +
                                `This will create DUPLICATES in Apple Photos.\n\n` +
                                `Continue anyway?`)) {
                        importStatus.style.display = 'none';
                        if (sendButton) sendButton.disabled = false;
                        if (gridSendButton) gridSendButton.disabled = false;
                        if (saveBtn) saveBtn.disabled = false;
                        updateSelectionUI();
                        return;
                    }
                }
                
                // Send photos
                importStatus.innerHTML = 
                    '<div style="color: var(--source-filename);">Sending photos...</div>';
                    
                const importResponse = await fetch('/api/import-photos', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({filepaths: selected})
                });
                
                if (importResponse.ok) {
                    const result = await importResponse.json();
                    importStatus.innerHTML = 
                        `<div style="color: var(--source-filename);">Processing ${selected.length} photo${selected.length > 1 ? 's' : ''}...</div>`;
                    selectedPhotos.clear();
                    updateSelectionUI();
                    
                    // Start monitoring pipeline progress
                    monitorPipelineProgress(result.batch_id);
                    
                } else {
                    const error = await importResponse.json();
                    importStatus.innerHTML = 
                        `<div style="color: var(--status-error);">${error.error || 'Error starting pipeline'}</div>`;
                    setTimeout(() => {
                        importStatus.style.display = 'none';
                        if (sendButton) sendButton.disabled = false;
                        if (gridSendButton) gridSendButton.disabled = false;
                        if (saveBtn) saveBtn.disabled = false;
                        updateSelectionUI();
                    }, 3000);
                }
            } catch (error) {
                console.error('Error:', error);
                importStatus.innerHTML = 
                    '<div style="color: var(--status-error);">Network error - please try again</div>';
                setTimeout(() => {
                    importStatus.style.display = 'none';
                    if (sendButton) sendButton.disabled = false;
                    if (gridSendButton) gridSendButton.disabled = false;
                    if (saveBtn) saveBtn.disabled = false;
                    updateSelectionUI();
                }, 3000);
            }
        }
        
        let pipelineMonitorInterval = null;
        
        async function monitorPipelineProgress(batchId) {
            const importStatus = document.getElementById('import-status');
            
            // Create progress display
            importStatus.innerHTML = `
                <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; margin-top: 16px;">
                    <div style="display: flex; align-items: center; margin-bottom: 12px;">
                        <div class="spinner" style="width: 24px; height: 24px; margin-right: 12px;"></div>
                        <div style="color: var(--source-filename); font-weight: 600;">Processing batch ${batchId}...</div>
                    </div>
                    <div id="pipeline-output" style="background: #000; color: #00ff00; font-family: monospace; font-size: 12px; padding: 12px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                        Starting pipeline...
                    </div>
                </div>
            `;
            importStatus.style.display = 'block';
            
            // Poll for status
            pipelineMonitorInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/pipeline-status');
                    const status = await response.json();
                    
                    // Update output display
                    const outputDiv = document.getElementById('pipeline-output');
                    if (outputDiv && status.output.length > 0) {
                        // Show last 10 lines
                        const recentLines = status.output.slice(-10);
                        outputDiv.innerHTML = recentLines.map(line => 
                            line.replace(/</g, '&lt;').replace(/>/g, '&gt;')
                        ).join('<br>');
                        outputDiv.scrollTop = outputDiv.scrollHeight;
                    }
                    
                    // Check if finished
                    if (!status.running) {
                        clearInterval(pipelineMonitorInterval);
                        pipelineMonitorInterval = null;
                        
                        // Show completion status
                        const success = status.exit_code === 0 && status.final_status === 'complete';
                        const statusColor = success ? 'var(--status-success)' : 'var(--status-error)';
                        const statusText = success ? 'completed successfully' : 'failed';
                        importStatus.innerHTML = 
                            '<div style="color: ' + statusColor + ';">' +
                            statusIcon + ' Pipeline ' + statusText +
                            '</div>';
                        
                        // Re-enable buttons
                        const sendButton = document.getElementById('send-button');
                        const gridSendButton = document.getElementById('grid-send-button');
                        const saveBtn = document.getElementById('save-btn');
                        if (sendButton) sendButton.disabled = false;
                        if (gridSendButton) gridSendButton.disabled = false;
                        if (saveBtn) saveBtn.disabled = false;
                        updateSelectionUI();
                        
                        // Reload to show import status
                        setTimeout(() => {
                            loadCurrentPhoto();
                            if (gridMode) {
                                showGridView(currentGridFilter, 0);
                            }
                            
                            // Hide status after a delay
                            setTimeout(() => {
                                importStatus.style.display = 'none';
                            }, 5000);
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error checking pipeline status:', error);
                }
            }, 1000); // Check every second
        }
        
        // Initialize location search
        async function initializeLocationSearch() {
            const input = document.getElementById('location-search');
            const clear = document.getElementById('location-clear');
            
            await loadFrequentLocations();
            
            input.addEventListener('input', handleLocationInput);
            clear.addEventListener('click', clearLocationSearch);
            
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.location-container')) {
                    hideLocationResults();
                }
            });
        }

        // Handle input changes
        async function handleLocationInput(e) {
            const query = e.target.value.trim();
            const clear = document.getElementById('location-clear');
            
            clear.style.display = query ? 'flex' : 'none';
            
            if (locationSearchState.searchTimeout) {
                clearTimeout(locationSearchState.searchTimeout);
            }
            
            if (query.length < 2) {
                hideLocationResults();
                return;
            }
            
            locationSearchState.searchTimeout = setTimeout(async () => {
                await searchLocations(query);
            }, 300);
        }

        // Search locations
        async function searchLocations(query) {
            try {
                showLocationLoading();
                
                const response = await fetch('/api/locations/search', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({query})
                });
                
                if (!response.ok) throw new Error('Search failed');
                
                const results = await response.json();
                displayLocationResults(results);
                
            } catch (error) {
                console.error('Location search error:', error);
                hideLocationResults();
            }
        }

        // Display search results
        function displayLocationResults(results) {
            const container = document.getElementById('location-results');
            locationSearchState.results = results;
            
            if (!results.length) {
                container.innerHTML = '<div class="empty-results">No locations found</div>';
                container.style.display = 'block';
                return;
            }
            
            // Group results by category
            const grouped = {
                STATE: [],
                CITY: [],
                ADDRESS: [],
                POI: [],
                COUNTRY: []
            };
            
            results.forEach(loc => {
                const category = loc.category || 'CITY';
                if (grouped[category]) {
                    grouped[category].push(loc);
                }
            });
            
            let html = '';
            
            // Render each category
            Object.entries(grouped).forEach(([category, items]) => {
                if (items.length === 0) return;
                
                const categoryNames = {
                    STATE: 'States',
                    CITY: 'Cities', 
                    ADDRESS: 'Addresses',
                    POI: 'Places',
                    COUNTRY: 'Countries'
                };
                
                html += `<div class="result-section">
                    <div class="section-header">${categoryNames[category]}</div>`;
                
                items.forEach((loc, index) => {
                    const usage = loc.use_count > 0 ? 
                        `<span class="usage-badge">${loc.use_count} uses</span>` : '';
                    
                    html += `
                        <div class="result-item" data-result='${JSON.stringify(loc).replace(/'/g, '&apos;')}'>
                            <span class="result-category ${category.toLowerCase()}">${category}</span>
                            <div class="result-content">
                                <div class="result-title">${loc.display_primary}</div>
                                <div class="result-subtitle">${loc.display_secondary}</div>
                            </div>
                            <div class="result-meta">${usage}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            container.innerHTML = html;
            container.style.display = 'block';
            
            // Add click handlers
            container.querySelectorAll('.result-item').forEach((item) => {
                item.addEventListener('click', () => {
                    const location = JSON.parse(item.dataset.result);
                    selectLocation(location);
                });
            });
        }

        // Select a location
        function selectLocation(location) {
            locationSearchState.currentLocation = location;
            
            const input = document.getElementById('location-search');
            const container = document.getElementById('location-results');
            
            // Show what was selected
            input.value = location.display_full;
            input.style.borderColor = 'var(--status-success)';
            
            // Show a brief confirmation in the results area
            container.innerHTML = `
                <div style="padding: 16px; text-align: center; color: #34C759;">
                    Selected: ${location.display_primary}
                    <div style="font-size: 12px; color: #8E8E93; margin-top: 4px;">
                        ${location.display_secondary}
                    </div>
                </div>
            `;
            
            // Hide after a moment
            setTimeout(() => {
                hideLocationResults();
            }, 1500);
        }

        // Load frequent locations
        async function loadFrequentLocations() {
            try {
                const response = await fetch('/api/locations/frequent?limit=5');
                const locations = await response.json();
                
                const container = document.getElementById('frequent-pills');
                container.innerHTML = locations.map((loc, index) => `
                    <div class="frequent-pill" data-index="${index}" title="${loc.display_full}">
                        <span class="pill-text">${loc.display_primary}</span>
                        <span class="pill-count">${loc.use_count}</span>
                    </div>
                `).join('');
                
                container.querySelectorAll('.frequent-pill').forEach((pill) => {
                    pill.addEventListener('click', () => {
                        const index = parseInt(pill.dataset.index);
                        selectLocation(locations[index]);
                    });
                });
                
            } catch (error) {
                console.error('Failed to load frequent locations:', error);
            }
        }

        // Clear location search
        function clearLocationSearch() {
            document.getElementById('location-search').value = '';
            document.getElementById('location-clear').style.display = 'none';
            hideLocationResults();
            locationSearchState.currentLocation = null;
        }

        function showLocationLoading() {
            const container = document.getElementById('location-results');
            container.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
            container.style.display = 'block';
        }

        function hideLocationResults() {
            document.getElementById('location-results').style.display = 'none';
        }
        
        // Load current photo
        async function loadCurrentPhoto() {
            // Clear any pending re-send state
            clearResendState();
            
            try {
                const response = await fetch('/api/current');
                const data = await response.json();
                
                if (!response.ok) {
                    console.error('Failed to load photo:', data.error);
                    // Clear currentPhoto when filter is empty
                    currentPhoto = null;
                    // Handle empty filter
                    if (data.filtered_total === 0) {
                        // Clear the photo display
                        const photoContainer = document.querySelector('.photo-container');
                        photoContainer.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary);">
                                <div style="font-size: 18px;">No photos in this filter</div>
                                <div style="font-size: 14px; margin-top: 8px;">Try a different filter</div>
                            </div>
                        `;
                        // Update stats
                        if (data.stats) {
                            updateStats(data.stats);
                        }
                        // Clear metadata panel
                        clearAllInputs();
                        document.getElementById('current-date').textContent = 'No photo selected';
                        document.getElementById('current-location').textContent = 'No photo selected';
                        document.getElementById('current-tags').textContent = 'No photo selected';
                        document.getElementById('current-import-status').textContent = 'No photo selected';
                        
                        // Clear photo header
                        document.getElementById('filename').textContent = 'No photos in filter';
                        document.getElementById('file-counter').textContent = '0 of 0';
                        
                        // Hide suggestion buttons
                        document.getElementById('date-suggestion-btn').style.display = 'none';
                        document.getElementById('location-suggestion-btn').style.display = 'none';
                        const dualContainer = document.getElementById('location-dual-container');
                        if (dualContainer) dualContainer.remove();
                        
                        // Disable action buttons
                        document.getElementById('save-btn').disabled = true;
                        document.getElementById('send-button').disabled = true;
                    }
                    return;
                }
                
                currentPhoto = data;
                updateUI(data);
                
            } catch (error) {
                console.error('Error loading photo:', error);
            }
        }

        // Poll for LLM suggestions
        function startLLMPolling(filepath) {
            // Tear down any previous poll
            if (llmPollTimeout) {
                clearTimeout(llmPollTimeout);
                llmPollTimeout = null;
            }

            function poll() {
                // Only poll if still on the same photo
                if (!currentPhoto || currentPhoto.filepath !== filepath) {
                    return;
                }

                fetch(`/api/suggestions/${encodeURIComponent(filepath)}`)
                    .then(r => r.json())
                    .then(data => {
                        if (data.status === 'ready') {
                            // Got the final result → stop polling & update UI
                            clearTimeout(llmPollTimeout);
                            llmPollTimeout = null;
                            dateSuggestion     = data.date_suggestion;
                            locationSuggestion = data.location_suggestion;
                            updateLLMSuggestions(data.date_suggestion, data.location_suggestion);
                        } else {
                            // Still pending → poll again in 500ms
                            llmPollTimeout = setTimeout(poll, 500);
                        }
                    })
                    .catch(err => {
                        clearTimeout(llmPollTimeout);
                        llmPollTimeout = null;
                    });
            }

            // Kick off the first check after a short delay
            llmPollTimeout = setTimeout(poll, 300);
        }

        
        // Update UI with LLM suggestions
        function updateLLMSuggestions(dateSug, locationSug) {
            // Only proceed if we actually have suggestions
            if (!dateSug && !locationSug)  {
                // Parsing finished but nothing to suggest → just clear “Analyzing”
                document.getElementById('date-suggestion-btn').style.display = 'none';
                const dual = document.getElementById('location-dual-container'); if (dual) dual.remove();
                return;
            }
            // --- DATE SUGGESTION ---
            const dateBtn = document.getElementById('date-suggestion-btn');
            if (dateSug) {
                dateSuggestion = dateSug;
                let sugText = 'Suggested: ';
                if (dateSug.month && dateSug.year) {
                    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                    const idx = parseInt(dateSug.month, 10) - 1;
                    sugText += dateSug.day
                        ? `${monthNames[idx]||dateSug.month} ${dateSug.day}, ${dateSug.year}`
                        : `${monthNames[idx]||dateSug.month} ${dateSug.year}`;
                } else if (dateSug.year) {
                    sugText += dateSug.year;
                }
                dateBtn.textContent   = sugText;
                dateBtn.disabled      = false;
                dateBtn.style.display = 'block';
                fieldSources.wasCompleteSuggestion = !!dateSug.is_complete;
            }

            // --- LOCATION SUGGESTION ---
            const locBtn = document.getElementById('location-suggestion-btn');
            const oldDual = document.getElementById('location-dual-container');
            if (oldDual) oldDual.remove();

            if (locationSug && locationSug.primary_search) {
                locBtn.style.display = 'none';
                const container = document.createElement('div');
                container.id = 'location-dual-container';
                container.className = 'location-dual-container';

                const makeBtn = (text, alt) => {
                    const b = document.createElement('button');
                    b.className = 'btn' + (alt ? ' alternate' : '');
                    b.textContent = text;
                    b.onclick     = () => acceptLocationSuggestion(alt);
                    return b;
                };

                container.append(
                    makeBtn(`Specific: ${locationSug.primary_search}`, false),
                    locationSug.alternate_search
                        ? makeBtn(`General:  ${locationSug.alternate_search}`, true)
                        : document.createTextNode('')
                );

                const sectionTitle = locBtn.parentNode;
             sectionTitle.parentNode.insertBefore(
                 container,
                 sectionTitle.nextSibling
             );
            } else {
                locBtn.style.display = locationSug ? 'block' : 'none';
            }
        }

        // Update entire UI
        function updateUI(data) {
            // Reset unknown button states
            unknownDateActive = false;
            unknownLocationActive = false;
            document.querySelectorAll('.quick-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Clear previous location state
            locationSearchState.currentLocation = null;
            locationSearchState.results = [];
            document.getElementById('location-search').style.borderColor = '';

            // Photo display
            document.getElementById('filename').textContent = data.filename;
            document.getElementById('file-counter').textContent = 
                `${data.current_index + 1} of ${data.filtered_total}`;
            
            // Ensure photo container has proper structure
            const photoContainer = document.querySelector('.photo-container');
            if (!document.getElementById('photo')) {
                photoContainer.classList.remove('grid-mode');
                photoContainer.innerHTML = `
                    <div id="loading" class="loading">
                        <div class="spinner"></div>
                    </div>
                    <img id="photo" style="display: none;" />
                    
                    <div class="nav-controls">
                        <button class="nav-btn" id="prev-btn" onclick="navigatePhoto(-1)">←</button>
                        <button class="nav-btn" id="next-btn" onclick="navigatePhoto(1)">→</button>
                    </div>
                `;
            }
            
            // If we're loading a photo, ensure we're not in grid mode
            if (document.querySelector('.photo-grid')) {
                const photoContainer = document.querySelector('.photo-container');
                photoContainer.classList.remove('grid-mode');
                photoContainer.innerHTML = `
                    <div id="loading" class="loading">
                        <div class="spinner"></div>
                    </div>
                    <img id="photo" style="display: none;" />
                    
                    <div class="nav-controls">
                        <button class="nav-btn" id="prev-btn" onclick="navigatePhoto(-1)">←</button>
                        <button class="nav-btn" id="next-btn" onclick="navigatePhoto(1)">→</button>
                    </div>
                `;
            }
            
            // Load image
            const img = document.getElementById('photo');
            const loading = document.getElementById('loading');
            
            img.style.display = 'none';
            loading.style.display = 'flex';
            
            img.onload = () => {
                loading.style.display = 'none';
                img.style.display = 'block';
            };
            
            img.src = `data:image/jpeg;base64,${data.image_data}`;
            
            // Stats
            updateStats(data.stats);
            
            // Clear inputs first
            clearAllInputs();
            
            // Fill date fields
            if (data.date) {
                setDateFields(data.date);
            }
            
            // Suggestions
            dateSuggestion = data.date_suggestion;
            locationSuggestion = data.location_suggestion;
            
            // Check if LLM parsing is pending
            if (data.llm_status === 'pending') {
                // Start polling for results
                startLLMPolling(data.filepath);
                
                }
            
            // Update suggestion button text with preview
            const dateSugBtn = document.getElementById('date-suggestion-btn');
            if (data.llm_status === 'pending' && !dateSuggestion) {
                // Show analyzing state
                dateSugBtn.textContent = 'Analyzing...';
                dateSugBtn.style.display = 'block';
                dateSugBtn.disabled = true;
            } else if (dateSuggestion) {
                let sugText = 'Suggested: ';
                if (dateSuggestion.month && dateSuggestion.year) {
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const monthIndex = parseInt(dateSuggestion.month) - 1;
                    const monthName = (monthIndex >= 0 && monthIndex < 12) ? 
                                     monthNames[monthIndex] : dateSuggestion.month;
                    sugText += dateSuggestion.day ? 
                        `${monthName} ${dateSuggestion.day}, ${dateSuggestion.year}` :
                        `${monthName} ${dateSuggestion.year}`;
                } else if (dateSuggestion.year) {
                    sugText += dateSuggestion.year;
                }
                dateSugBtn.textContent = sugText;
                dateSugBtn.style.display = 'block';
                dateSugBtn.disabled = false;
            } else {
                dateSugBtn.style.display = 'none';
            }
            
            const locSugBtn = document.getElementById('location-suggestion-btn');
            const existingDualContainer = document.getElementById('location-dual-container');
            
            // Clean up any existing dual container
            if (existingDualContainer) {
                existingDualContainer.remove();
            }
            
            if (data.llm_status === 'pending' && !locationSuggestion) {
                // Show analyzing state using simple button below title
                locSugBtn.style.display = 'none';
                
                // Create analyzing button container
                const dualContainer = document.createElement('div');
                dualContainer.id = 'location-dual-container';
                dualContainer.className = 'location-dual-container';
                
                const analyzingBtn = document.createElement('button');
                analyzingBtn.className = 'btn';
                analyzingBtn.textContent = 'Analyzing...';
                analyzingBtn.disabled = true;
                
                dualContainer.appendChild(analyzingBtn);
                
                const sectionTitle = locSugBtn.parentNode;
                sectionTitle.parentNode.insertBefore(dualContainer, sectionTitle.nextSibling);
                
            } else if (locationSuggestion && locationSuggestion.primary_search) {
                // Hide single button
                locSugBtn.style.display = 'none';
                
                // Create dual button container
                const dualContainer = document.createElement('div');
                dualContainer.id = 'location-dual-container';
                dualContainer.className = 'location-dual-container';
                
                // Create primary button
                const primaryBtn = document.createElement('button');
                primaryBtn.className = 'btn';
                primaryBtn.textContent = `Specific: ${locationSuggestion.primary_search}`;
                primaryBtn.onclick = function() { 
                    if (window.acceptLocationSuggestion) {
                        window.acceptLocationSuggestion(false);
                    }
                };
                
                dualContainer.appendChild(primaryBtn);
                
                // Create alternate button if available
                if (locationSuggestion.alternate_search) {
                    const alternateBtn = document.createElement('button');
                    alternateBtn.className = 'btn alternate';
                    alternateBtn.textContent = `General: ${locationSuggestion.alternate_search}`;
                    alternateBtn.onclick = function() { 
                        if (window.acceptLocationSuggestion) {
                            window.acceptLocationSuggestion(true);
                        }
                    };
                    
                    dualContainer.appendChild(alternateBtn);
                }
                
                // Insert after the section title
                const sectionTitle = locSugBtn.parentNode;
                sectionTitle.parentNode.insertBefore(dualContainer, sectionTitle.nextSibling);
                
            } else if (locationSuggestion) {
                // Fallback to old format - always hide single button
                locSugBtn.style.display = 'none';
            } else {
                locSugBtn.style.display = 'none';
            }
            
            // Current metadata display
            updateCurrentMetadataDisplay(data);

            // Update import status display
            if (data.imported_at) {
                document.getElementById('current-import-status').innerHTML = 
                    `<span style="color: #34C759;">Imported ${new Date(data.imported_at).toLocaleDateString()}</span>`;
                // Update send button to show already imported
                const sendBtn = document.getElementById('send-button');
                if (sendBtn) {
                    sendBtn.textContent = 'Already in Photos';
                }
            } else {
                document.getElementById('current-import-status').textContent = 'Not imported';
            }
            // Update send button based on state (moved outside if block)
            const sendBtn = document.getElementById('send-button');
            if (sendBtn) {
                if (data.imported_at) {
                    sendBtn.textContent = 'Already in Photos';
                    sendBtn.classList.remove('warning-state');
                } else if (!data.last_saved_at) {
                    sendBtn.textContent = 'Save First';
                } else {
                    sendBtn.textContent = 'Send to Photos';
                }
            }

            updateSelectionUI();

            // Ensure save button is enabled when viewing a photo
            document.getElementById('save-btn').disabled = false;

            // Store save status in currentPhoto
            currentPhoto.last_saved_at = data.last_saved_at;
            
            // Navigation buttons
            updateNavigationButtons();
        }
        
        // Set date fields with source tracking
        function setDateFields(date) {
            const fields = ['year', 'month', 'day'];
            
            fields.forEach(field => {
                const input = document.getElementById(field);
                const badge = document.getElementById(`${field}-badge`);
                const value = date[field] || '';
                const source = date[`${field}_source`];
                
                input.value = value;
                // CRITICAL: Store the source for later use in save
                fieldSources[field] = source;
                
                if (source === 'system') {
                    input.classList.add('system-value');
                    badge.textContent = 'System';
                    badge.className = 'source-badge system';
                    badge.style.display = 'inline-block';
                } else if (source === 'user') {
                    input.classList.remove('system-value');
                    badge.textContent = 'User';
                    badge.className = 'source-badge user';
                    badge.style.display = 'inline-block';
                } else {
                    input.classList.remove('system-value');
                    badge.style.display = 'none';
                }
            });
            
            // Set the complete suggestion flag if it exists
            fieldSources.wasCompleteSuggestion = date.from_complete_suggestion || false;
        }
        
        // Clear all inputs
        function clearAllInputs() {
            ['year', 'month', 'day'].forEach(id => {
                const input = document.getElementById(id);
                const badge = document.getElementById(`${id}-badge`);
                
                input.value = '';
                input.classList.remove('system-value', 'unknown-value');
                input.disabled = false;
                badge.style.display = 'none';
                fieldSources[id] = null;
            });
            fieldSources.wasCompleteSuggestion = false;
            
            // Clear location state
            const searchInput = document.getElementById('location-search');
            searchInput.classList.remove('unknown-value');
            searchInput.disabled = false;
            searchInput.placeholder = 'Search for a place';
            locationSearchState.currentLocation = null;
            searchInput.value = '';
            document.getElementById('location-clear').style.display = 'none';
        }
        
        // Update stats display
        function updateStats(stats) {
            document.getElementById('stat-needs-review').textContent = stats.needs_review || 0;
            document.getElementById('stat-needs-both').textContent = stats.needs_both || 0;
            document.getElementById('stat-needs-date').textContent = stats.needs_date || 0;
            document.getElementById('stat-needs-location').textContent = stats.needs_location || 0;
            document.getElementById('stat-complete').textContent = stats.complete || 0;
        }
        
        // Update current metadata display
        function updateCurrentMetadataDisplay(data) {
            // Date
            if (data.date) {
                const dateStr = `${data.date.year}-${data.date.month}-${data.date.day}`;
                // Determine overall source - if any field is system, show system
                let dateSource = 'user';
                if (data.date.year_source === 'system' || 
                    data.date.month_source === 'system' || 
                    data.date.day_source === 'system') {
                    dateSource = 'system';
                }
                
                document.getElementById('current-date').innerHTML = `
                    <div>${dateStr}</div>
                    <div style="font-size: 11px; color: var(--source-${dateSource});">
                        Source: ${dateSource}
                    </div>
                `;
            } else {
                document.getElementById('current-date').textContent = 'Not set';
            }
            
            // Location display
            const locationDisplay = document.getElementById('current-location');
            let locationHTML = '';
            
            if (data.smart_location) {
                // Use smart location display
                const loc = data.smart_location;
                const categoryBadge = loc.category ? 
                    `<span class="result-category ${loc.category.toLowerCase()}">${loc.category}</span>` : '';
                
                locationHTML = `
                    <div class="location-display">
                        ${categoryBadge}
                        <div class="location-details">
                            <div class="location-primary">${loc.display_primary}</div>
                            <div class="location-secondary">${loc.display_secondary}</div>
                        </div>
                    </div>
                `;
            } else if (data.location) {
                // Show city/state if available
                if (data.location.city || data.location.state) {
                    let locStr = data.location.city ? 
                        `${data.location.city}, ${data.location.state}` : 
                        data.location.state;
                    locationHTML = `<div>${locStr}</div>`;
                }
                
                // Add GPS coordinates if available
                if (data.location.has_gps && data.location.gps_lat !== null && data.location.gps_lon !== null) {
                    const lat = data.location.gps_lat.toFixed(6);
                    const lon = data.location.gps_lon.toFixed(6);
                    const gpsSource = data.location.gps_source || 'unknown';
                    
                    locationHTML += `
                        <div style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                            <div>GPS: ${lat}, ${lon}</div>
                            <div style="font-size: 11px; color: var(--source-${gpsSource});">
                                Source: ${gpsSource}
                            </div>
                        </div>
                    `;
                }
            }
            
            if (locationHTML) {
                locationDisplay.innerHTML = locationHTML;
            } else {
                locationDisplay.textContent = 'Not set';
            }
            
            // Tags
            if (data.tags && data.tags.length > 0) {
                document.getElementById('current-tags').textContent = data.tags.join(', ');
            } else {
                document.getElementById('current-tags').textContent = 'None';
            }
            
            // Camera data indicator
            const metadataDiv = document.querySelector('.current-metadata');
            let cameraIndicator = document.getElementById('camera-indicator');
            
            if (data.has_camera_data) {
                if (!cameraIndicator) {
                    // Create camera indicator if it doesn't exist
                    const indicatorHtml = `
                        <div class="metadata-item" id="camera-indicator">
                            <div class="metadata-label">Camera Data</div>
                            <div class="metadata-value">
                                ${data.camera_info.make} ${data.camera_info.model}
                            </div>
                        </div>
                    `;
                    metadataDiv.insertAdjacentHTML('beforeend', indicatorHtml);
                } else {
                    // Update existing indicator
                    cameraIndicator.querySelector('.metadata-value').innerHTML = 
                        `${data.camera_info.make} ${data.camera_info.model}`;
                }
            } else if (cameraIndicator) {
                // Remove indicator if no camera data
                cameraIndicator.remove();
            }
        }
        
        // Update navigation buttons
        function updateNavigationButtons() {
            if (!currentPhoto) return;
            
            document.getElementById('prev-btn').disabled = currentPhoto.current_index === 0;
            document.getElementById('next-btn').disabled = 
                currentPhoto.current_index >= currentPhoto.filtered_total - 1;
        }
        
        // Accept date suggestion
        function acceptDateSuggestion() {
            if (!dateSuggestion) return;
            
            document.getElementById('year').value = dateSuggestion.year;
            
            if (dateSuggestion.month) {
                document.getElementById('month').value = dateSuggestion.month;
                fieldSources.month = 'user';
            } else {
                document.getElementById('month').value = '01';
                fieldSources.month = 'system';
            }
            
            if (dateSuggestion.day) {
                document.getElementById('day').value = dateSuggestion.day;
                fieldSources.day = 'user';
            } else {
                document.getElementById('day').value = '02';
                fieldSources.day = 'system';
            }
            
            fieldSources.year = 'user';
            fieldSources.wasCompleteSuggestion = dateSuggestion.is_complete;
            
            updateFieldBadge('year', 'user');
            updateFieldBadge('month', fieldSources.month);
            updateFieldBadge('day', fieldSources.day);
        }
        
        // Accept location suggestion - now handles primary/alternate
        async function acceptLocationSuggestion(useAlternate = false) {
            if (!locationSuggestion) return;

            // Determine which search to use
            let query;
            if (useAlternate && locationSuggestion.alternate_search) {
                query = locationSuggestion.alternate_search;
            } else if (locationSuggestion.primary_search) {
                query = locationSuggestion.primary_search;
            } else {
                // Fallback to old format if needed
                let queryParts = [];
                if (locationSuggestion.city) queryParts.push(locationSuggestion.city);
                if (locationSuggestion.state) queryParts.push(locationSuggestion.state);
                if (locationSuggestion.country && locationSuggestion.country !== '' && 
                    locationSuggestion.country !== 'United States') {
                    queryParts.push(locationSuggestion.country);
                }
                query = queryParts.join(', ');
            }
            
            if (!query) return;

            // Put it in the input
            const input = document.getElementById('location-search');
            input.value = query;
            document.getElementById('location-clear').style.display = 'flex';
            
            // Add visual feedback for confidence (with safety check)
            if (locationSuggestion.confidence !== undefined) {
                const confidenceColor = locationSuggestion.confidence > 80 ? '#34C759' : 
                                       locationSuggestion.confidence > 50 ? '#FF9500' : '#FF453A';
                input.style.borderColor = confidenceColor;
                
                // Reset border color after a moment
                setTimeout(() => {
                    input.style.borderColor = '';
                }, 3000);
            }

            // Launch search
            await searchLocations(query);
        }
        
        // Update field badge
        function updateFieldBadge(fieldId, source) {
            const input = document.getElementById(fieldId);
            const badge = document.getElementById(`${fieldId}-badge`);
            
            if (source === 'system') {
                input.classList.add('system-value');
                badge.textContent = 'System';
                badge.className = 'source-badge system';
                badge.style.display = 'inline-block';
            } else if (source === 'user') {
                input.classList.remove('system-value');
                badge.textContent = 'User';
                badge.className = 'source-badge user';
                badge.style.display = 'inline-block';
            } else {
                input.classList.remove('system-value');
                badge.style.display = 'none';
            }
        }
        
        // Set unknown date
        async function setUnknownDate() {
            const button = event.target;
            
            if (unknownDateActive) {
                // Toggle off - clear everything
                button.classList.remove('active');
                unknownDateActive = false;
                
                ['year', 'month', 'day'].forEach(field => {
                    const input = document.getElementById(field);
                    const badge = document.getElementById(`${field}-badge`);
                    
                    input.value = '';
                    input.classList.remove('system-value', 'unknown-value');
                    input.disabled = false;
                    badge.style.display = 'none';
                    fieldSources[field] = null;
                });
                fieldSources.wasCompleteSuggestion = false;
            } else {
                // Toggle on - set unknown values
                button.classList.add('active');
                unknownDateActive = true;
                
                try {
                    const response = await fetch('/api/unknown_date', { method: 'POST' });
                    const data = await response.json();
                    
                    if (data.success) {
                        document.getElementById('year').value = data.year;
                        document.getElementById('month').value = data.month;
                        document.getElementById('day').value = data.day;
                        
                        ['year', 'month', 'day'].forEach(field => {
                            const input = document.getElementById(field);
                            input.classList.remove('system-value');
                            input.classList.add('unknown-value');
                            input.disabled = true;
                            fieldSources[field] = data.source;
                            updateFieldBadge(field, data.source);
                        });
                        fieldSources.wasCompleteSuggestion = false;
                    }
                } catch (error) {
                    console.error('Error setting unknown date:', error);
                }
            }
        }
        
        // Set unknown location
        async function setUnknownLocation() {
            const button = event.target;
            const searchInput = document.getElementById('location-search');
            
            if (unknownLocationActive) {
                // Toggle off
                button.classList.remove('active');
                searchInput.classList.remove('unknown-value');
                searchInput.disabled = false;
                searchInput.value = '';
                searchInput.placeholder = 'Search for a place';
                unknownLocationActive = false;
                
                clearLocationSearch();
            } else {
                // Toggle on
                button.classList.add('active');
                searchInput.classList.add('unknown-value');
                searchInput.disabled = true;
                unknownLocationActive = true;

                clearLocationSearch();
                searchInput.value = 'Unknown';  // Set value AFTER clearing

                // Notify Flask so the change is recorded //
                try {
                    const resp  = await fetch('/api/unknown_location', { method: 'POST' });
                    const data  = await resp.json();
                    if (data.success) {
                        // keep source badges in sync
                        updateFieldBadge('location', data.source);
                    }
                } catch (err) {
                    console.error('Error setting unknown location:', err);
                }
            }
        }
        
        // Save and next
        async function saveAndNext() {
            const saveData = {};
            
            // Collect date data
            const year = document.getElementById('year').value.trim();
            const month = document.getElementById('month').value.trim();
            const day = document.getElementById('day').value.trim();
            
            if (year) {
                saveData.date = {
                    year: year,
                    month: month,
                    day: day,
                    year_source: fieldSources.year || 'system',
                    month_source: fieldSources.month || 'system',
                    day_source: fieldSources.day || 'system',
                    from_complete_suggestion: fieldSources.wasCompleteSuggestion || false
                };
            }
            
            // Also send current photo's camera data flag
            if (currentPhoto && currentPhoto.has_camera_data) {
                saveData.has_camera_data = true;
            }
            
            // Location data
            if (locationSearchState.currentLocation) {
                saveData.smart_location = locationSearchState.currentLocation;
            } else if (currentPhoto && currentPhoto.location && currentPhoto.location.has_gps) {
                // Preserve existing GPS when no new location selected
                saveData.preserve_gps = {
                    gps_lat: currentPhoto.location.gps_lat,
                    gps_lon: currentPhoto.location.gps_lon,
                    gps_source: currentPhoto.location.gps_source
                };
            }
            
            try {
                const response = await fetch('/api/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(saveData)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Update local state immediately
                    if (currentPhoto) {
                        currentPhoto.last_saved_at = new Date().toISOString();
                        updateSelectionUI();
                    }
                    
                    if (result.has_next) {
                        loadCurrentPhoto();
                    } else {
                        // Just reload to show empty state
                        loadCurrentPhoto();
                    }
                } else {
                    alert(result.error || 'Failed to save metadata');
                }
                
            } catch (error) {
                console.error('Error saving:', error);
                alert('Network error - please try again');
            }
        }
        
        // Skip photo
        async function skipPhoto() {
            // Function kept for potential future use but not used in UI
            try {
                const response = await fetch('/api/skip', { method: 'POST' });
                const result = await response.json();
                
                if (result.has_next) {
                    loadCurrentPhoto();
                } else {
                    // Just reload to show empty stat
                    loadCurrentPhoto();
                }
                
            } catch (error) {
                console.error('Error skipping:', error);
            }
        }
        
        // Navigate photos
        async function navigatePhoto(direction) {
            // Clear any pending re-send state
            clearResendState();
            
            // Clear LLM polling
            if (llmPollTimeout) {
                clearTimeout(llmPollTimeout);
                llmPollTimeout = null;
            }
            
            try {
                // Check bounds locally first
                if (!currentPhoto) return;
                
                const newIndex = currentPhoto.current_index + direction;
                if (newIndex < 0 || newIndex >= currentPhoto.filtered_total) {
                    return;
                }
                
                const response = await fetch('/api/navigate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ direction: direction })
                });
                
                if (response.ok) {
                    loadCurrentPhoto();
                }
                
            } catch (error) {
                console.error('Error navigating:', error);
            }
        }
        
        // Set filter
        async function setFilter(filter, element) {
            // Clear any pending re-send state
            clearResendState();
            
            // Clear LLM polling
            if (llmPollTimeout) {
                clearTimeout(llmPollTimeout);
                llmPollTimeout = null;
            }
            
            // Check if clicking the same active filter
            const isCurrentFilter = currentPhoto && currentPhoto.current_filter === filter;
            const wasGridMode = gridMode && currentGridFilter === filter;
            
            // If in grid mode and clicking a different filter, exit grid first
            if (gridMode && filter !== currentGridFilter) {
                gridMode = false;
                currentGridFilter = null;
                // Clear the photo container
                const photoContainer = document.querySelector('.photo-container');
                photoContainer.innerHTML = `
                    <div id="loading" class="loading">
                        <div class="spinner"></div>
                    </div>
                    <img id="photo" style="display: none;" />
                    
                    <div class="nav-controls">
                        <button class="nav-btn" id="prev-btn" onclick="navigatePhoto(-1)">←</button>
                        <button class="nav-btn" id="next-btn" onclick="navigatePhoto(1)">→</button>
                    </div>
                `;
            }
            
            // Remove all active and grid-mode classes
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('active', 'grid-mode');
            });
            
            if (isCurrentFilter && !wasGridMode) {
                // Second click on active card - enter grid mode
                if (element) {
                    element.classList.add('active', 'grid-mode');
                }
                gridMode = true;
                currentGridFilter = filter;
                // Check if the filter has any photos first
                const testResponse = await fetch('/api/current');
                const testData = await testResponse.json();
                
                if (!testResponse.ok || (testData.stats && testData.stats[filter.replace('_', '')] === 0)) {
                    // Show empty state instead of grid
                    const photoContainer = document.querySelector('.photo-container');
                    photoContainer.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary);">
                            <div style="font-size: 18px;">No photos in this filter</div>
                        </div>
                    `;
                    element.classList.remove('grid-mode');
                    gridMode = false;
                    currentGridFilter = null;
                } else {
                    await showGridView(filter, currentPhoto ? currentPhoto.current_index : 0);
                }
            } else if (wasGridMode) {
                // Clicking grid card again - exit grid mode
                gridMode = false;
                currentGridFilter = null;
                if (element) {
                    element.classList.add('active');
                }
                // Reload current photo
                await loadCurrentPhoto();
            } else {
                // Normal filter change
                gridMode = false;
                currentGridFilter = null;
                
                if (element) {
                    element.classList.add('active');
                } else {
                    const cards = document.querySelectorAll('.stat-card');
                    const filterMap = ['needs_review', 'needs_both', 'needs_location', 'needs_date', 'complete'];
                    const index = filterMap.indexOf(filter);
                    if (index >= 0 && cards[index]) {
                        cards[index].classList.add('active');
                    }
                }
                
                try {
                    const response = await fetch('/api/filter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filter: filter })
                    });
                    
                    if (response.ok) {
                        await loadCurrentPhoto();
                    }
                    
                } catch (error) {
                    console.error('Error setting filter:', error);
                }
            }
        }
        
        // Toggle sort mode
        async function toggleSort() {
            try {
                const response = await fetch('/api/toggle_sort', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Reload current view with new sort order
                    if (gridMode) {
                        // If in grid mode, refresh grid
                        await showGridView(currentGridFilter, 0);
                    } else {
                        // Reset to first photo with new sort
                        STATE.current_index = 0;
                        await loadCurrentPhoto();
                    }
                }
            } catch (error) {
                console.error('Error toggling sort:', error);
            }
        }
        
        // Show grid view
        async function showGridView(filter, startIndex = 0) {
            const photoContainer = document.querySelector('.photo-container');
            
            // Show loading state
            photoContainer.classList.add('grid-mode');
            
            // Update UI for grid mode
            updateSelectionUI();
            photoContainer.innerHTML = `
                <div class="photo-grid" id="photo-grid">
                    <div class="grid-selection-bar" style="grid-column: 1 / -1; background: var(--bg-secondary); padding: 12px 20px; border-radius: 8px; margin-bottom: 12px; display: flex; align-items: center; gap: 12px;">
                        <span id="grid-selection-count" style="font-weight: 600; color: var(--source-filename);">0 photos selected</span>
                        <button onclick="selectAllVisible()" class="quick-btn" style="margin: 0;">Select All</button>
                        <button onclick="selectNone()" class="quick-btn" style="margin: 0;">Clear</button>
                        <div style="flex: 1;"></div>
                        <button class="btn btn-import" onclick="sendToPhotos()" id="grid-send-button" disabled style="padding: 8px 16px;">Send to Photos</button>
                    </div>
                    <div class="grid-loading" style="grid-column: 1 / -1;">
                        <div class="spinner"></div>
                        <div>Loading photos...</div>
                    </div>
                </div>
            `;
            
            try {
                let page = 1;
                let hasMore = true;
                const gridContainer = document.getElementById('photo-grid');
                
                // Clear loading message after first batch
                let firstBatch = true;
                
                while (hasMore) {
                    const response = await fetch(`/api/grid/${filter}?page=${page}`);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to load grid');
                    }
                    
                    // Remove loading message on first batch
                    if (firstBatch) {
                        // Remove only the loading div, keep selection bar
                        const loadingDiv = gridContainer.querySelector('.grid-loading');
                        if (loadingDiv) loadingDiv.remove();
                        firstBatch = false;
                    }
                    
                    // Add photos to grid WITH current photo highlighting and checkboxes
                    let gridHTML = '';
                    data.photos.forEach(photo => {
                        const isCurrentPhoto = photo.index === startIndex;
                        const isSelected = selectedPhotos.has(photo.filepath);
                        const isImported = photo.imported_at ? true : false;
                        const isUnsaved = !photo.last_saved_at;
                        gridHTML += `
                            <div class="grid-item${isCurrentPhoto ? ' current-photo' : ''}" data-index="${photo.index}">
                                <input type="checkbox" 
                                       class="grid-checkbox" 
                                       data-filepath="${photo.filepath}"
                                       ${isSelected ? 'checked' : ''}
                                       ${isImported || isUnsaved ? 'disabled' : ''}
                                       onclick="event.stopPropagation(); toggleGridSelection('${photo.filepath}', ${isImported}, ${isUnsaved})"
                                       style="position: absolute; top: 8px; left: 8px; z-index: 10; width: 20px; height: 20px;">
                                ${isImported ? '<div style="position: absolute; top: 8px; right: 8px; background: #34C759; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold;">✓</div>' : ''}
                                <img src="data:image/jpeg;base64,${photo.thumbnail}" alt="${photo.filename}">
                                <div class="grid-index">${photo.index + 1}</div>
                            </div>
                        `;
                    });
                    
                    // Add all photos at once
                    gridContainer.insertAdjacentHTML('beforeend', gridHTML);
                    
                    // Add click handlers to new items
                    gridContainer.querySelectorAll('.grid-item:not([data-listener])').forEach(item => {
                        item.setAttribute('data-listener', 'true');
                        item.addEventListener('click', () => {
                            const index = parseInt(item.dataset.index);
                            exitGridMode(index);
                        });
                    });
                    
                    hasMore = data.has_more;
                    page++;
                }
                
                // After ALL photos are loaded, scroll to current photo with 30% offset
                const target = gridContainer.querySelector('.current-photo');
                if (target) {
                    setTimeout(() => {
                        const gridRect = gridContainer.getBoundingClientRect();
                        const itemRect = target.getBoundingClientRect();
                        const offset = gridRect.top + (gridRect.height * 0.3);
                        gridContainer.scrollTop += (itemRect.top - offset);
                    }, 100);
                }
                
            } catch (error) {
                console.error('Error loading grid:', error);
                document.getElementById('photo-grid').innerHTML = `
                    <div class="grid-loading">
                        <div style="color: var(--status-error);">Failed to load photos</div>
                    </div>
                `;
            }
        }
        
        // Exit grid mode
        async function exitGridMode(targetIndex = null) {
            gridMode = false;
            
            // Remove grid mode from cards
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('grid-mode');
            });
            
            // Navigate to specific photo if index provided
            if (targetIndex !== null && currentPhoto) {
                const jumpDistance = targetIndex - currentPhoto.current_index;
                try {
                    const response = await fetch('/api/navigate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ direction: jumpDistance })
                    });
                } catch (error) {
                    console.error('Error navigating to photo:', error);
                }
            }
            
            // Load the photo
            await loadCurrentPhoto();
        }

        // Track when user types (mark as user source)
        ['year', 'month', 'day'].forEach(id => {
            document.getElementById(id).addEventListener('input', function() {
                if (this.value) {
                    // Clear unknown state if user types
                    if (unknownDateActive) {
                        unknownDateActive = false;
                        document.querySelectorAll('.quick-btn')[0].classList.remove('active');
                        ['year', 'month', 'day'].forEach(field => {
                            const input = document.getElementById(field);
                            input.classList.remove('unknown-value');
                            input.disabled = false;
                        });
                    }
                    
                    fieldSources[id] = 'user';
                    updateFieldBadge(id, 'user');
                    if (['year', 'month', 'day'].includes(id)) {
                        fieldSources.wasCompleteSuggestion = false;
                    }
                }
            });
        });
        
        // Format inputs on blur
        document.getElementById('month').addEventListener('blur', function() {
            if (this.value && !isNaN(this.value)) {
                const month = parseInt(this.value);
                if (month >= 1 && month <= 12) {
                    this.value = month.toString().padStart(2, '0');
                }
            }
        });
        
        document.getElementById('day').addEventListener('blur', function() {
            if (this.value && !isNaN(this.value)) {
                const day = parseInt(this.value);
                if (day >= 1 && day <= 31) {
                    this.value = day.toString().padStart(2, '0');
                }
            }
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Save shortcut (Cmd/Ctrl + S)
            if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                e.preventDefault();
                if (currentPhoto && !gridMode) {
                    saveAndNext();
                }
                return;
            }
            
            // Don't process arrow keys if in an input field
            if (e.target.tagName === 'INPUT') return;
            
            if (e.key === 'ArrowLeft') {
                navigatePhoto(-1);
            } else if (e.key === 'ArrowRight') {
                navigatePhoto(1);
            }
        });
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeLocationSearch();
            loadCurrentPhoto();
            
            // Make function globally accessible for onclick handlers
            window.acceptLocationSuggestion = acceptLocationSuggestion;
        });
    </script>
</body>
</html>